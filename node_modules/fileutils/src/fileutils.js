/**
 * Changes:
 * > Made eachFileOrDirectory consistent with fs.readdir in that
 * the folder to traverse is not returned.
 * > Added option not to recurse folder.
 * > JSLint refactoring (lenient: vars allowed and some issues ignored).
 *
 * @modified DS
 **/

//JSLint static code analysis options:
/*jslint node: true, vars:true, plusplus:true, sloppy: true, stupid: true, white: true, maxerr: 10, indent: 4 */

var fs = require('fs'),
    pathModule = require('path'),
    pathSep = pathModule.sep; //SD: use proper path separator

/**
 * Call fileHandler with the file name and file Stat for each file found inside
 * of the provided directory.
 *
 * Call the optionally provided completeHandler with an array of files (mingled
 * with directories) and an array of Stat objects (one for each of the found
 * files.
 *
 * Following is an example of a simple usage:
 *
 *   eachFileOrDirectory('test/', true, function(err, file, stat) {
 *     if (err) throw err;
 *     if (!stat.isDirectory()) {
 *       console.log(">> Found file: " + file);
 *     }
 *   });
 *
 * Following is an example that waits for all files and directories to be
 * scanned and then uses the entire result to do somthing:
 *
 *   eachFileOrDirectory('test/', true, null, function(err, files, stats) {
 *     if (err) throw err;
 *     var len = files.length;
 *     for (var i = 0; i < len; i++) {
 *       if (!stats[i].isDirectory()) {
 *         console.log(">> Found file: " + files[i]);
 *       }
 *     }
 *   });
 */

/**
 * A generic tandem sort routine to sort one (values) array based on order of sorted another (keys) array.
 * @param keys (array) the initial array to sort, and whose sorted order determines the order to sort values.
 * @param values (array) the array to be sorted in tandem.
 * @param compare (optional function) comparison function to use. Defaults to simple a-b comparator.
 *
 * @author SD
 **/
function tandemSort(keys, values, compare)
{
    if (!(typeof keys === 'object') || (keys.length <= 1))
    {
        return; //nothing to do!
    }
    if (!(typeof values === 'object')
        || (keys.length !== values.length))
    {
        return; //abort: mismatched array sizes
    }
    const sortResults = [];
    let i = -1;
    function defaultCompare(a, b) //simple comparator
    {
        return a - b;
    }
    function captureCompare(a, b) //wrapper for comparator, used to capture comparison results
    {
        const result = compare(a, b);
        sortResults.push(result);
        return result;
    }
    function tandemCompare() //fake comparator to replicate results of initial sort
    {
        ++i;
        return sortResults[i];
    }
    if (typeof compare !== 'function')
    {
        compare = defaultCompare;
    }
    keys.sort(captureCompare);
    values.sort(tandemCompare); //use fake comparator to sort values in same manner as keys
}

//same as tandemSort, except sort 2 other arrays based on the keys.
function tandemSortDouble(keys, values, values2, compare)
{
    if (!(typeof keys === 'object') || (keys.length <= 1))
    {
        return; //nothing to do!
    }
    if (!(typeof values === 'object')
        || (keys.length !== values.length)
        || (keys.length !== values2.length))
    {
        return; //abort: mismatched array sizes
    }
    const sortResults = [];
    let i = -1;
    function defaultCompare(a, b) //simple comparator
    {
        return a - b;
    }
    function captureCompare(a, b) //wrapper for comparator, used to capture comparison results
    {
        const result = compare(a, b);
        sortResults.push(result);
        return result;
    }
    function tandemCompare() //fake comparator to replicate results of initial sort
    {
        ++i;
        return sortResults[i];
    }
    if (typeof compare !== 'function')
    {
        compare = defaultCompare;
    }
    keys.sort(captureCompare);
    values.sort(tandemCompare); //use fake comparator to sort values in same manner as keys
    values2.sort(tandemCompare);
}

/**
 * Asynchronously traverse the file system calling the provided
 * callback for each file or directory found.
 * Recursion is optional.
 *
 * @param directory (String) folder to traverse.
 * @param recurse (boolean; default: false) whether to recurse.
 * @param fileHandler (function) callback to trigger for each item found.
 *        Callback will receive err, file, stat.
 * @param completeHandler (function) callback to trigger when traversal is complete.
 *        Callback will receive err, files, stats.
 **/
var eachFileOrDirectory = function(directory, recurse, fileHandler, completeHandler) {
    var filesToCheck = 0;
    var checkedFiles = [];
    var checkedStats = [];

    recurse = !!recurse;

    directory = directory || './';

    var fullFilePath = function(dir, file) {
        return dir.replace(/\/$/, '') + pathSep + file;
    };

    var checkComplete = function() {
        if ((filesToCheck === 0) && (typeof completeHandler === 'function')) {
            completeHandler(null, checkedFiles, checkedStats);
        }
    };

    var onFileOrDirectory = function(fileOrDirectory, is1stFile) {
        filesToCheck++;
        fs.stat(fileOrDirectory, function(err, stat) {
            filesToCheck--;
            //SD: don't abort completely without informing completeHandler!
            //if (err) return fileHandler(err);
            if (err)
            {
                if (!is1stFile)
                {
                    if (typeof fileHandler === 'function')
                    {
                        fileHandler(err);
                    }
                }
            }
            else
            {
                if (!is1stFile)
                {
                    checkedFiles.push(fileOrDirectory);
                    checkedStats.push(stat);
                    if (typeof fileHandler === 'function')
                    {
                        fileHandler(null, fileOrDirectory, stat);
                    }
                }
                if (is1stFile || (recurse && stat.isDirectory()))
                {
                    onDirectory(fileOrDirectory);
                }
            }
            checkComplete();
        });
    };

    var onDirectory = function(dir) {
        filesToCheck++;
        fs.readdir(dir, function(err, files) {
            filesToCheck--;
            if (err)
            {
                if (typeof fileHandler === 'function')
                {
                    return fileHandler(err);
                }
                return;
            }
            files.forEach(function(file) {
                file = fullFilePath(dir, file);
                onFileOrDirectory(file);
            });
            checkComplete();
        });
    };

    onFileOrDirectory(directory, true);
};

/**
 * Recursivly, asynchronously traverse the file system calling the provided
 * callback for each file (non-directory) found.
 *
 * Traversal will begin on the provided path.
 */
var eachFile = function(path, recurse, callback, completeHandler) {
    var files = [];
    var stats = [];

    eachFileOrDirectory(path, recurse,
        function(err, file, stat) {
            if (err)
            {
                return callback(err);
            }
            if (!stat.isDirectory()) {
                files.push(file);
                stats.push(stat);
                if (typeof callback === 'function')
                {
                    callback(null, file, stat);
                }
            }
        },
        (typeof completeHandler === 'function')? function(err) {
            if (err)
            {
                return completeHandler(err);
            }
            completeHandler(null, files, stats);
        }: undefined);
};

/**
 * Similar to eachFile but for directory.
 */
var eachDirectory = function(path, recurse, callback, completeHandler) {
    var files = [];
    var stats = [];

    eachFileOrDirectory(path, recurse, function(err, file, stat) {
        if (err)
        {
            if (typeof callback === 'function')
            {
                return callback(err);
            }
            return;
        }
        if (stat.isDirectory()) {
            files.push(file);
            stats.push(stat);
            if (typeof callback === 'function')
            {
                callback(null, file, stat);
            }
        }
    }, (typeof completeHandler === 'function')? function(err) {
        if (err)
        {
            return completeHandler(err);
        }
        if (completeHandler)
        {
            completeHandler(null, files, stats);
        }
    }: undefined);
};

/**
 * Works just like eachFile, but it only includes files that match a provided
 * regular expression.
 *
 *   eachFileMatching(/_test.js/, 'test', function(err, file, stat) {
 *     if (err) throw err;
 *     console.log(">> Found file: " + file);
 *   });
 *
 */
var eachFileMatching = function(expression, path, recurse, callback, completeHandler) {
    var files = [];
    var stats = [];

    eachFile(path, recurse, function(err, file, stat) {
        if (err)
        {
            if (typeof callback === 'function')
            {
                return callback(err);
            }
            return;
        }
        if (expression.test(file)) {
            files.push(file);
            stats.push(stat);
            if (typeof callback === 'function')
            {
                callback(null, file, stat);
            }
        }
    }, (typeof completeHandler === 'function')? function(err) {
        if (err)
        {
            return completeHandler(err);
        }
        completeHandler(null, files, stats);
    }: undefined);
};

/**
 * Similar to eachFileMatching, except with results sorted based on base filenames.
 * @param keygen (function) method to keygen and generate a key for each file for sorting use.
 *                           Will be called on each file prior to sorting.
 *                           Signature: (file, stat).
 * @param compare (function) comparison method for sorting use.
 *
 * @author SD
 **/
var eachFileMatchingSorted = function(expression, path, recurse, keygen, compare, callback, completeHandler) {
    //default key generator assumes filename is integer
    function defPrep(file /*, stat*/)
    {
        try
        {
            return parseInt(pathModule.basename(file));
        }
        catch (ignore) {}
        return 0;
    }
    var files = [];
    var stats = [];

    if (typeof keygen !== 'function')
    {
        keygen = defPrep;
    }

    eachFile(path, recurse, function(err, file, stat) {
        if (err)
        {
            if (typeof callback === 'function')
            {
                return callback(err);
            }
            return;
        }
        if (expression.test(file)) {
            files.push(file);
            stats.push(stat);
        }
    }, function(err) {
        if (err)
        {
            if (typeof completeHandler === 'function')
            {
                return completeHandler(err);
            }
            return;
        }

        //sort results
        const keys = [];
        files.forEach((file, i) => {
            keys.push(keygen(file, stats[i]));
        });
        tandemSortDouble(keys, files, stats, compare);

        //unlike eachFileMatching, we only iterate each file after all are sorted
        if (typeof callback === 'function')
        {
            files.forEach((e, i) => {
                callback(null, e, stats[i]);
            });
        }
        if (typeof completeHandler === 'function')
        {
            completeHandler(null, files, stats);
        }
    });
};

/**
 * Read each file with a file name that matches the provided expression
 * and was found in the provided path.
 *
 * Calls the optionally provided callback for each file found.
 *
 * Calls the optionally provided completeHandler when the search is
 * complete.
 *
 *   readEachFileMatching(/_test.js/, 'test', function(err, file, stat, content) {
 *     if (err) throw err;
 *     console.log(">> Found file: " + file + " with: " + content.length + " chars");
 *   });
 */
var readEachFileMatching = function(expression, recurse, path, callback, completeHandler) {
    var files = [];
    var contents = [];
    var stats = [];

    eachFileMatching(expression, recurse, path, function(err, file, stat) {
        if (err)
        {
            if (typeof callback === 'function')
            {
                return callback(err); //SD: abort upon error
            }
            return;
        }
        fs.readFile(file, function(err, content) {
            if (err)
            {
                if (typeof callback === 'function')
                {
                    return callback(err);
                }
                return;
            }
            files.push(file);
            contents.push(content);
            stats.push(stat);
            if (typeof callback === 'function')
            {
                callback(null, file, stat, content);
            }
        });
    }, (typeof completeHandler !== 'function')? function(err) {
        if (err)
        {
            return completeHandler(err);
        }
        if (completeHandler)
        {
            completeHandler(err, files, stats, contents);
        }
    }: undefined);
};

exports.eachFile = eachFile;
exports.eachDirectory = eachDirectory;
exports.eachFileMatching = eachFileMatching;
exports.eachFileMatchingSorted = eachFileMatchingSorted;
exports.eachFileOrDirectory = eachFileOrDirectory;
exports.readEachFileMatching = readEachFileMatching;
